### 单例模式说明
1、饿汉模式  HungryInstance

优点：类加载的时候就对类进行初始化，避免的线程同步问题。
缺点：类加载的时候就初始化，如果一直未使用会对内存造成一定的浪费

2、懒汉模式  
* 非线程安全      LazySingletonOne  
    不可用，未处理多线程问题会创建多个对象
* 线程安全同步块   LazySingletonTwo   
    可用，但是效率很低，每次获取单例都会锁住类，影响效率
* 线程安全非同步块  LazySingletonThree
    不可用，在多线程情况下还是会存在多次加锁进行验证并创建多个对象的情况
* 线程安全双检测    LazySingletonFour
    可用，多线程情况下因为加锁并且在同步块中进行了对象判断故不会存在创建多个对象，同时也实现了延迟加载，初始化未使用情况下的内存浪费
* 静态内部类  InnerSingleton
    可用，采用了类装载的机制来保证初始化实例时只有一个线程，内部类被加载但是不会被使用，有且仅当在调用instance的时候才会初始化静态块创建单例对象
* 枚举   EnumSingle
    可用，采用JDK1.5中添加的枚举来实现单例模式，避免了多线程同步问题而且还能防止反序列化重新创建新的对象。 

3、破坏单例的方式
* 反射   
  单例虽然将构造函数设置为私有域，反射可用设置调用私有域并创建新对象
* 序列化和反序列化
  序列化与反序列化得到的对象是一个新的对象。因为序列化会通过反射调用无参数的构造方法创建一个新的对象。可用定义readResolve方法，并在该方法中指定要返回的对象的生成策略，就可以防止单例被破坏。

4、内部类执行时序图  
          